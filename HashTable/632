# Condition: 1) smallest range includes at least one number from each of the k lists; 2) if two ranges equals, use the one with smaller a.

# 0,4,5,9,10,12,15,18,20,22,24,26,30
 # Thought DongDong: 1)Merge all sublist into one big sort list; 
              2)loop range and check if all list contain at least one number in this range, and flag. e.g. range= (0,4)
              3)Then increase step from 1 to 2, check range = [0,5] and if contains. And then keep on loop [point, point +step]
              4)Exit when all ranges checked and return saved samllest range.
              
 # Thought 1: 
# Condition: 1) smallest range includes at least one number from each of the k lists; 2) if two ranges equals, use the one with smaller a.

# 0,4,5,9,10,12,15,18,20,22,24,26,30
 # Thought 1: 

class Solution:
    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        print(len(nums)) #k value
        print(len(nums[0])) # number of elements in sublist
        p = [0]*len(nums) #Sublist position list
        for i in range(len(nums)):
            p[i] = len(nums[i])-1
        print('k list position token from end: ', p)
        # print(nums[1][2])
        newList = []
        range=[-inf,inf]
        while sum(p) >0:
            for i in range(len(nums)):
                # print( nums[i][p[i]])
                newList.append(nums[i][p[i]])
                i=i-1
            # print("newList: ",newList)
            
    def calculateRange(self, list):
        m=min(list)
        x=max(list)
        range = [m,x]
        # call movePointer function to check if need to move pointers
        return range
    
    def movePointer(range,p):
        

    
    
